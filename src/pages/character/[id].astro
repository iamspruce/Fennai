---
// src/pages/character/[id].astro (UPDATED WITH VOICESLIST)
import BaseLayout from "@/layouts/BaseLayout.astro";
import { getCurrentUser } from "@/lib/firebase/auth";
import {
  getCharacter,
  getVoices,
  getCharacters,
  getDubbingJobs,
} from "@/lib/firebase/firestore";

// UI Components
import CharacterHeader from "@/components/character/CharacterHeader.astro";
import Pagination from "@/components/character/Pagination.astro";
import StorageWarning from "@/components/character/StorageWarning.astro";
import MigrationBanner from "@/components/character/MigrationBanner";
import MediaList from "@/components/character/MediaList"; // NEW
import VoiceInputSection from "@/components/character/VoiceInputSection";

// React Islands
import CloningModal from "@/islands/CloningModal";
import ScriptGeneratorModal from "@/islands/ScriptGeneratorModal";
import DubMediaSelectModal from "@/islands/dub/DubMediaSelectModal";
import DubSettingsModal from "@/islands/dub/DubSettingsModal";
import DubReviewModal from "@/islands/dub/DubReviewModal";
import DubSegmentSelectorModal from "@/islands/dub/DubSegmentSelectorModal";
import DubEditScriptModal from "@/islands/dub/DubEditScriptModal";

const { id } = Astro.params;
const user = await getCurrentUser(Astro);

if (!user || !id) return Astro.redirect("/profile");

const url = new URL(Astro.request.url);
const page = parseInt(url.searchParams.get("page") || "1");
const limit = 20;

// OPTIMIZATION: Run all queries in parallel
const startTime = Date.now();
const [
  character,
  { characters: allCharacters },
  { voices: allVoices },
  { jobs: allDubbingJobs },
] = await Promise.all([
  getCharacter(id, user.uid),
  getCharacters(user.uid, { limit: 100 }),
  getVoices(id, user.uid, {
    limit: limit + 1, // Fetch limit + 1 to check if there are more
  }),
  getDubbingJobs(id, user.uid, { limit: 100 }),
]);

console.log(
  `[Performance] Character page loaded in ${Date.now() - startTime}ms`
);

if (!character) return Astro.redirect("/profile");

// NEW: Split voices by storage type
const cloudVoices = allVoices.filter((v) => v.storageType === "cloud");
const localOnlyVoices = allVoices.filter((v) => v.storageType === "local-only");

// Extract local-only IDs for client-side checking
const localOnlyIds = localOnlyVoices.map((v) => v.id);

// NEW: Handle dubbing jobs similar to voices
const cloudDubbingJobs = allDubbingJobs.filter(
  (j) => j.saveAcrossBrowsers === true || j.storageType === "cloud"
);
const localOnlyDubbingIds = allDubbingJobs
  .filter(
    (j) => j.saveAcrossBrowsers === false || j.storageType === "local-only"
  )
  .map((j) => j.id);

// NEW: Identify audio dubs to count them as voices
const audioDubsCount = allDubbingJobs.filter(
  (j) => j.mediaType === "audio"
).length;
const videoDubsCount = allDubbingJobs.filter(
  (j) => j.mediaType === "video"
).length;

// Pagination based on total voices
const hasMore = allVoices.length > limit;
const voices = hasMore ? allVoices.slice(0, limit) : allVoices;
const hasPrevious = page > 1;

const userTier = user.isPro ? "pro" : "free";
---

<BaseLayout
  title={`${character.name} - Fennai`}
  isPro={user.isPro}
  userName={user.displayName}
>
  <StorageWarning />
  <MigrationBanner
    client:load
    characterId={character.id}
    isPro={user.isPro}
    saveAcrossBrowsers={character.saveAcrossBrowsers || false}
  />

  <div class="page-modal">
    <CharacterHeader
      character={character}
      voiceCount={(character.voiceCount || 0) + audioDubsCount}
      syncedVoiceCount={cloudVoices.length}
      dubbedCount={videoDubsCount}
    />

    <main class="character-main">
      <MediaList
        client:only="react"
        cloudVoices={cloudVoices}
        localOnlyIds={localOnlyIds}
        cloudDubbingJobs={cloudDubbingJobs}
        localOnlyDubbingIds={localOnlyDubbingIds}
        mainCharacter={character}
        allCharacters={allCharacters}
        userId={user.uid}
        isPro={user.isPro}
      />

      <Pagination
        page={page}
        hasMore={hasMore}
        hasPrevious={hasPrevious}
        baseUrl={`/character/${id}`}
      />

      <div style="height: 200px;"></div>
    </main>
  </div>

  <VoiceInputSection
    client:load
    character={character}
    allCharacters={allCharacters}
  />

  {/* Modals */}
  <CloningModal client:load />

  <ScriptGeneratorModal
    client:load
    character={character}
    allCharacters={allCharacters}
    userTier={userTier}
    userCredits={user.credits}
  />
  <DubMediaSelectModal
    client:load
    character={character}
    allCharacters={allCharacters}
    userTier={userTier}
  />
  <DubSettingsModal client:load allCharacters={allCharacters} />
  <DubSegmentSelectorModal client:load />
  <DubEditScriptModal client:load />
  <DubReviewModal client:load />
</BaseLayout>

<script>
  import { saveVoiceToIndexedDB, initDB } from "@/lib/db/indexdb";

  let pendingVoiceData: any = null;

  // Safari-compatible WAV validation function
  async function validateWAVBlob(blob: Blob): Promise<boolean> {
    if (blob.size < 44) {
      console.error("[Voice] Audio file too small");
      return false;
    }

    try {
      const headerBuffer = await blob.slice(0, 44).arrayBuffer();
      const view = new DataView(headerBuffer);

      // Check RIFF signature
      const riff = String.fromCharCode(
        view.getUint8(0),
        view.getUint8(1),
        view.getUint8(2),
        view.getUint8(3)
      );

      if (riff !== "RIFF") {
        console.error("[Voice] Invalid RIFF header:", riff);
        return false;
      }

      // Check WAVE signature
      const wave = String.fromCharCode(
        view.getUint8(8),
        view.getUint8(9),
        view.getUint8(10),
        view.getUint8(11)
      );

      if (wave !== "WAVE") {
        console.error("[Voice] Invalid WAVE header:", wave);
        return false;
      }

      console.log("[Voice] WAV validation passed ✓");
      return true;
    } catch (error) {
      console.error("[Voice] WAV validation error:", error);
      return false;
    }
  }

  // Handle Preview Modal - Store character dialogue data
  window.addEventListener("open-preview-modal", (e: any) => {
    if (e.detail.characterId && e.detail.text) {
      pendingVoiceData = {
        ...e.detail,
        dialogues:
          e.detail.isMultiCharacter && e.detail.characterIds
            ? e.detail.characterIds.map((charId: string, idx: number) => ({
                characterId: charId,
                text: e.detail.texts ? e.detail.texts[idx] : e.detail.text,
              }))
            : [{ characterId: e.detail.characterId, text: e.detail.text }],
      };

      console.log("[Voice] Preview modal opened with data:", {
        characterId: pendingVoiceData.characterId,
        isMultiCharacter: pendingVoiceData.isMultiCharacter,
      });
    }
  });

  // Consolidate Audio reading for Safari Mobile compatibility
  async function readBlobAsArrayBuffer(blob: Blob): Promise<ArrayBuffer> {
    if (typeof blob.arrayBuffer === "function") {
      try {
        return await blob.arrayBuffer();
      } catch (e) {
        console.warn(
          "[Voice] blob.arrayBuffer() failed, falling back to FileReader",
          e
        );
      }
    }

    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as ArrayBuffer);
      reader.onerror = () => reject(new Error("Failed to read audio data"));
      reader.readAsArrayBuffer(blob);
    });
  }

  // Enhanced Save Logic with Safari validation
  window.addEventListener("voice-edited", async (e: any) => {
    console.log("[Voice] Received voice-edited event");

    if (!pendingVoiceData) {
      console.error("[Voice] No pending voice data");
      window.dispatchEvent(
        new CustomEvent("show-alert", {
          detail: {
            title: "Missing Data",
            message:
              "No voice data to save. This can happen if the page was refreshed or memory was cleared. Please try recording again.",
            type: "error",
          },
        })
      );
      return;
    }

    const { blob } = e.detail;

    if (!blob || !(blob instanceof Blob)) {
      console.error("[Voice] Invalid audio blob", blob);
      window.dispatchEvent(
        new CustomEvent("show-alert", {
          detail: {
            title: "Invalid Data",
            message:
              "Failed to save: Invalid audio data received. (Type: " +
              typeof blob +
              ")",
            type: "error",
          },
        })
      );
      return;
    }

    if (blob.size === 0) {
      console.error("[Voice] Empty audio blob");
      window.dispatchEvent(
        new CustomEvent("show-alert", {
          detail: {
            title: "Empty Audio",
            message:
              "Failed to save: Audio file is empty. Please try trimming a larger section.",
            type: "error",
          },
        })
      );
      return;
    }

    try {
      // Validate WAV blob for Safari compatibility
      console.log(
        "[Voice] Validating audio format (Size: " + blob.size + " bytes)..."
      );
      const isValid = await validateWAVBlob(blob);

      if (!isValid) {
        console.error("[Voice] WAV validation failed");
        window.dispatchEvent(
          new CustomEvent("show-alert", {
            detail: {
              title: "Validation Failed",
              message:
                "The audio file is empty or corrupted. This often happens on Safari/iOS if the microphone permission was interrupted. Please reload and try again.",
              type: "error",
            },
          })
        );
        return;
      }

      // Calculate actual duration from audio buffer if available
      let duration = e.detail.duration || blob.size / 16000; // Prefer event duration or fallback estimate

      try {
        console.log(
          "[Voice] Attempting to decode audio for precise duration..."
        );
        const arrayBuffer = await readBlobAsArrayBuffer(blob);

        // Safari Mobile: Use webkitAudioContext if AudioContext is not available
        const AudioContextClass =
          window.AudioContext || (window as any).webkitAudioContext;
        const audioContext = new AudioContextClass();

        try {
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          duration = audioBuffer.duration;
          console.log("[Voice] Precise duration decoded:", duration);
        } catch (decodeErr) {
          console.warn(
            "[Voice] decodeAudioData failed, using provided/estimated duration:",
            decodeErr
          );
        } finally {
          if (audioContext.state !== "closed") {
            await audioContext.close();
          }
        }
      } catch (err) {
        console.warn(
          "[Voice] Duration calculation error, using fallback:",
          err
        );
      }

      const formData = new FormData();
      formData.append("characterId", pendingVoiceData.characterId);
      formData.append("text", pendingVoiceData.text);

      // CRITICAL for Safari: Create a real File object from the blob
      const audioFile = new File([blob], "voice.wav", { type: "audio/wav" });
      formData.append("audioBlob", audioFile);

      formData.append("duration", String(duration));
      formData.append(
        "isMultiCharacter",
        String(pendingVoiceData.isMultiCharacter || false)
      );

      if (pendingVoiceData.characterIds) {
        formData.append(
          "characterIds",
          JSON.stringify(pendingVoiceData.characterIds)
        );
      }

      if (pendingVoiceData.dialogues) {
        formData.append(
          "dialogues",
          JSON.stringify(pendingVoiceData.dialogues)
        );
      }

      // Save to server
      let response;
      try {
        response = await fetch("/api/voices/save", {
          method: "POST",
          body: formData,
        });
      } catch (fetchErr: any) {
        console.error("[Voice] Fetch failed:", fetchErr);
        window.dispatchEvent(
          new CustomEvent("show-alert", {
            detail: {
              title: "Network Error",
              message:
                "Failed to connect to the server. Please check your internet connection.",
              type: "error",
              details: fetchErr.message || String(fetchErr),
            },
          })
        );
        throw fetchErr;
      }

      let data;
      let textResponse = "";
      try {
        textResponse = await response.text();
        data = JSON.parse(textResponse);
      } catch (e) {
        console.error(
          "[Voice] Failed to parse server response:",
          e,
          textResponse
        );
        data = {
          error: "Invalid server response",
          details: textResponse.substring(0, 500), // Capture some of the raw response
        };
      }

      if (!response.ok) {
        const errorMsg =
          data.error ||
          `Server returned ${response.status}: ${response.statusText}`;
        window.dispatchEvent(
          new CustomEvent("show-alert", {
            detail: {
              title: "Server Error",
              message: errorMsg,
              type: "error",
              details:
                data.details ||
                `Status: ${response.status} ${response.statusText}\nResponse: ${textResponse.substring(0, 200)}`,
            },
          })
        );
        throw new Error(errorMsg);
      }

      // Handle storage based on storageType
      if (data.storageType === "cloud") {
        if (data.audioUrl) {
          try {
            console.log("[Voice] Caching audio locally...");
            const audioResponse = await fetch(data.audioUrl);
            const audioBlob = await audioResponse.blob();

            if (audioBlob.size > 0) {
              await saveVoiceToIndexedDB({
                id: data.voiceId,
                characterId: pendingVoiceData.characterId,
                text: pendingVoiceData.text,
                audioBlob,
                isMultiCharacter: pendingVoiceData.isMultiCharacter || false,
                characterIds: pendingVoiceData.characterIds,
                dialogues: pendingVoiceData.dialogues,
                duration: duration,
                createdAt: Date.now(),
                isInCloudStorage: true,
              });
              console.log("[Voice] Cached locally ✓");
            }
          } catch (cacheError) {
            console.warn(
              "[Voice] Local cache failed (non-critical):",
              cacheError
            );
          }
        }
      } else if (data.storageType === "local-only" && data.audioData) {
        console.log("[Voice] Saving to local IndexedDB...");

        try {
          const base64Response = await fetch(data.audioData);
          const audioBlob = await base64Response.blob();

          if (audioBlob.size > 0) {
            await saveVoiceToIndexedDB({
              id: data.voiceId,
              characterId: pendingVoiceData.characterId,
              text: pendingVoiceData.text,
              audioBlob,
              isMultiCharacter: pendingVoiceData.isMultiCharacter || false,
              characterIds: pendingVoiceData.characterIds,
              dialogues: pendingVoiceData.dialogues,
              duration: duration,
              createdAt: Date.now(),
              isInCloudStorage: false,
            });
            console.log("[Voice] Saved to IndexedDB ✓");
          }
        } catch (idbError) {
          console.error("[Voice] IDB save failed:", idbError);
          window.dispatchEvent(
            new CustomEvent("show-alert", {
              detail: {
                title: "Storage Error",
                message:
                  "Metadata saved, but failed to store audio locally. Refresh the page to see if it appears.",
                type: "warning",
              },
            })
          );
        }
      }

      // Clear pending data and reload
      pendingVoiceData = null;
      console.log("[Voice] Save complete! Reloading...");

      setTimeout(() => {
        window.location.reload();
      }, 500);
    } catch (error: any) {
      console.error("[Voice] CRITICAL SAVE ERROR:", error);

      // Detailed error logging for mobile debugging
      const errorDetails = {
        name: error.name || "UnknownError",
        message: error.message || "No error message",
        stack: error.stack || "No stack trace",
        cause: error.cause ? JSON.stringify(error.cause) : undefined,
      };

      window.dispatchEvent(
        new CustomEvent("show-alert", {
          detail: {
            title: "Save Failed",
            message:
              "We encountered a critical error while saving. This helps us fix the issue. Please take a screenshot.",
            type: "error",
            details: `Error: ${errorDetails.name}\nMessage: ${errorDetails.message}\nStack: ${errorDetails.stack}`,
          },
        })
      );
    }
  });
</script>

<style>
  .character-main {
    max-width: 800px;
    margin: 0 auto;
    padding-bottom: var(--space-l);
  }
</style>
